---
pubDatetime: 2023-09-26T00:33:00Z
title: OSTEP 32 Concurrency Bugs
featured: false
tags:
  - OSTEP
  - Concurrency
  - Computer-Science
  - OS
ogImage: ""
description: OS:TEP 32장 공부한 거 정리
---

## Table of contents

## 들어가며

대부분의 초기 병행성 관련 오류 연구는 `deadlock`에 초점이 맞추어져 있었다.
최근의 연구들은 다른 종류의 병행성 버그들 (비교착 상태 버그)을 다룬다.
이번 장에서 다룰 핵심 문제는 다음과 같다.

> **일반적인 병행성 관련 오류들을 어떻게 처리하는가?**
> 병행성 버그는 몇 가지의 전형적인 패턴을 갖는다.
> 튼튼하고 올바른 병행 코드를 작성하기 위한 가장 첫 단계는 어떤 경우들을 피해야 할지 파악하는 것.

## 오류의 종류

첫 번째 질문은 이것이다.

> **복잡한 병행 프로그램에서 발생하는 병행성 오류들은 어떤 것들이 있는가?**

대표적인 오픈 소스 프로그램 4개를 예로 들어 설명한다.

`MySQL` , `Apache`, `Mozilla`, `OpenOffice`
![](/public/image/ostep-32-concurrency-bugs-1695656687000.jpeg)
상기 표는 예로 든 병행 프로그램에서의 병행성 오류들을 표로 나타낸 것이다.
비교착 상태와 교착 상태의 오류로 나뉜 것을 알 수 있다.

## 비교착 상태 오류

상기 표를 보면 비교착 상태 오류가 병행성 오류의 과반수를 차지한다.

그것들은 어떤 종류일까?
어떻게 발생하는가?
어떻게 해결할 수 있는가?

대표적인 두 종류의 오류인 **원자성 위반(atomicity violation)** 과 **순서 위반(order violation)** 오류를 살펴본다.

#### 원자성 위반 오류 (atomicity violation)

![](/public/image/ostep-32-concurrency-bugs-1695656996684.jpeg)
상기 예제는 MySQL에서 발견한 간단한 예제이다.
`thd` 자료 구조의 `proc_info` 필드를 두 개의 딴 쓰레드들이 접근한다.
첫 번째 쓰레드는 그 필드가 NULL인지 검사하고, 두 번째 쓰레드는 그 필드를 NULL로 바꾼다.
만약 다음과 같은 상황을 가정해 보자.

1. 첫 번째 쓰레드가 검사를 완료한 후에, `fputs`를 호출하기 전에 interrupt가 발생한다.
2. 이로 인해서, 두 번째 쓰레드가 실행되어, 필드의 값을 NULL로 바꾼다.
3. `fputs`는 NULL 포인터 역참조를 하게 되어, 프로그램은 크래시된다.

원자성 위반 오류의 정의는 다음과 같다.

> **다수의 메모리 참조 연산들 간에 있어 예상했던 직렬성(serializability)이 보장되지 보장되지 않았다. (즉, 코드의 일부에 원자성이 요구됐으나, 실행 시에 그 원자성이 위반됐다.)**

어느 부분이 문제일까?

NULL값 검사와 `fputs` 호출 시 `proc_info`를 인자로 사용할 때, 원자적으로 실행되는 것 (_atomicity assumption_)을 가정했다.
근데, 이 가정이 깨진 것이다.

어떻게 해결할까?

락을 추가해, 어느 쓰레드든 `proc_info` 필드 접근 시, `proc_info_lock` 락 변수를 획득토록 한다.

![](/public/image/ostep-32-concurrency-bugs-1695658112849.jpeg)

### 순서 위반 오류 (order violation)

![](/public/image/ostep-32-concurrency-bugs-1695658149124.jpeg)
상기 코드에서 쓰레드 2의 코드는 `mThread`가 이미 NULL이 아닌 어떤 값으로 초기화 됐다고 가정했다.
하지만, 만약 쓰레드 1이 먼저 실행되지 않았다면, 쓰레드 2는 NULL 포인터를 사용하기 때문에 프로그램이 크래시될 것이다. (`mThread`의 초기값이 NULL이라고 가정했는데, NULL 값이 아닌 다른 값이라 한다면, 더 이상한 일이 발생한다. 임의의 메모리 주소를 접근하는 재앙이... NULL이라고 가정하여 크래시되는 게 낫다.)

순서 위반 오류의 정의는 다음과 같다.

> **두 개의 (그룹의) 메모리 참조 간의 순서가 바뀌었다. (즉, A가 항상 B보다 먼저 실행되어야 하지만 실행 중에 그 순서가 지켜지지 않았다)**

이런 오류를 수정하는 방법은 순서를 강제하는 것이다.
이런 종류의 동기화에는 컨디션 변수가 딱이다.

![](/public/image/ostep-32-concurrency-bugs-1695658465160.jpeg)
쓰레드 간의 순서가 문제가 된다면, 컨디션 변수 (또는 세마포어)를 사용하여 해결할 수 있다.

## 교착 상태 오류

락 L1을 갖고 있는 쓰레드 1 또 다른 락 L2를 기다리는 상황에서, 불행히도 락 L2를 갖고 있는 쓰레드 2가 락 L1이 해제되기를 기다리고 있을 때 교착 상태가 발생한다.
교착 상태가 발생할 가능성이 있는 코드 다음에 나타냈다.

![](/public/image/ostep-32-concurrency-bugs-1695658932509.jpeg)
상기 코드는 교착 상태가 나타날 수 있는 코드를 나타낸다.
이 코드에서는 교착 상태가 발생할 수 있다.
발생하는 경우를 살펴보자.
쓰레드 1이 락 L1을 획득하고 난 후에 context switch가 발생하여 쓰레드 2가 실행한다.
그때, 쓰레드 2 가 락 L2를 획득하고 락 L1을 획득하려고 시도한다.
그러면 교착 상태가 발생한다.
각 쓰레드가 상대방이 소유하고 있는 락을 대기하고 있기 때문에 누구도 실행할 수 없게 된다.
하기에 도표로 나타내었다.
그래프에서 사이클(cycle) 의 존재는 교착 상태 발생 가능성을 의미한다.
이 그림이 문제를 명확히 해줄 것이다.
교착 상태를 방지하기 위해서는 어떻게 코드를 작성해야 할까?

![](/public/image/ostep-32-concurrency-bugs-1695659204882.jpeg)

### 교착 상태는 왜 발생하는가?

앞서 본 상황은 손 쉽게 막을 수 있다고 생각할 수 있다.
쓰레드 1과 2가 락을 같은 순서로 획득한다면 절대 발생하지 않는다.
그러면 교착 상태는 대체 왜 발생할까?
**한 가지 이유**는 코드가 많아지면서 구성 요소 간에 **복잡한 의존성**이 발생하기 때문이다.
예를 들어, OS를 생각해 보자.
가상 메모리 시스템이 디스크 블럭을 가져오기 위해 파일 시스템을 접근하는 경우가 있다.
파일 시스템은 디스크 블럭을 메모리에 탑재하기 위해 메모리 페이지를 확보해야 하고, 이를 위해 가상 메모리 시스템에 접근한다.

**또 다른 이유**는 **캡슐화(encapsulation)** 성질 때문이다.
소프트웨어 모듈화가 개발을 쉽게 하기 때문에, 개발자들은 상세한 구현 내용은 감추라고 교육받는다.
그렇지만, 모듈화와 락은 잘 조화되지 않는다.
전혀 문제가 없어 보이는 인터페이스도 교착 상태를 발생시킨다.
예를 들어, 자바의 `Vector` 클래스에서 `AddAll()` 메소드를 생각해 보자.

```java
Vector v1, v2;
v1.AddAll(v2);
```

이 메소드는 멀티 쓰레드에 안전해야 하기 때문에 내부적으로는 v1 에 더해지는 벡터뿐만 아니라 인자로 전달되는 v2에 대한 락도 같이 획득해야 한다.
이 루틴은 v2 의 내용을 v1에 더하기 위해서 임의의 순서로 말한 락들을 획득하는데, 여기서는 v1을 먼저 획득하고 v2를 획득한다고 하자.
어떤 쓰레드가 `v2.AddAll(v1)`을 거의 동시에 호출하면 교착 상태 발생 가능성이 있다.
이 모든 상황은 호출한 응용 프로그램 모르게 진행된다.

### 교착 상태 발생 조건

교착 상태가 발생하기 위해서는 네 가지 조건이 충족돼야 한다.

- **상호 배제 (Mutual Exclusion)**: 쓰레드가 자신이 필요로 하는 자원에 대한 독자적인 제어권을 주장한다. (예, 쓰레드가 락을 획득함.)

- **점유 및 대기 (Hold-and-Wait)**: 쓰레드가 자신에게 할당된 자원 (예, 이미 획득한 락) 을 점유한 채로 다른 자원 (예, 획득하고자 하는 락) 을 대기한다.

- **비선점 (No Preemption)**: 자원 (락) 을 점유하고 있는 쓰레드로부터 자원을 강제적으로 빼앗을 수 없다.

- **환형 대기 (Circular Wait)**: 각 쓰레드는 다음 쓰레드가 요청한 하나 또는 그 이상의 자원 (락) 을 갖고 있는 쓰레드들의 순환 고리가 있다.

이 중 하나라도 만족하지 않는다면 교착 상태는 발생하지 않는다.
먼저 교착 상태를 예방할 수 있는 기술들을 알아 보자.

### 순환 대기 (Circular Wait)

**OSTEP 교재를 그대로 인용했습니다. 딱히 요약할 필요가 없을 거 같아서요.**

> 가장 실용적인 교착 상태 예방 기법은 (그리고 자주 사용되는 방법이기도 함) 순환 대기가 절대 발생하지 않도록 락 코드를 작성하는 것이다.
> 가장 간단한 방법은 락 획득을 하는 전체 순서 (total ordering) 를 정하는 것이다.
> 예를 들어, L1과 L2라는 두 개의 락만이 시스템에 존재하면 L1을 무조건 L2 전에 획득하도록 하면 교착 상태를 피할 수 있다.
> 이 순서를 따르면 순환 대기는 발생하지 않고 따라서 교착 상태도 발생하지 않는다.
> 물론, 좀 더 복잡한 시스템의 경우, 두 개 이상의 락이 존재할 것이고 전체 락의 요청 순서를 정의하는 것이 어려울 수 있다. (또는, 불필요할 수 있다.)
> 교착 상태를 피하기 위해 부분 순서 (partial ordering) 를 제공하는 것이 락 획득 구조를 만드는 데 유용할 것이다.
> Linux의 메모리 매핑 코드가 부분 순서를 제공받아 락을 획득하는 방식에 대한 좋은 예다.
> 소스 코드의 상단의 주석을 보면 열 개의 서로 다른 그룹으로 묶여 있는 락과 그에 대한 획득 순서를 볼 수 있다.
> 그 순서에는 "`i_mmap_mutex` 전에 `i_mutex`"를 획득해야 한다는 간단한 것부터 좀 더 복잡한 "`mapping->tree_lock` 전에 `swap_lock`, 그 전에 `private_lock`, 그리고 그 전에 `i_mmap_mutex`"과 같은 순서도 있다.
> 전체 또는 부분 순서를 제공하기 위해서는 세심하게 락 획득 전략을 설계해야 한다.
> 더 나아가 순서라는 것은 단순히 관례이기 때문에 숙련되지 않은 개발자들이 이 관례를 무시하고 코드를 개발할 경우, 교착 상태가 발생할 수 있다.
> 마지막으로 락의 순서를 정의하기 위해서는 코드와 다양한 루틴 간의 상호 호출 관계를 이해해야 한다.
> 작은 실수라 할지라도 "D" (Deadlock) 로 시작하는 문제를 만날 수 있게 된다.
