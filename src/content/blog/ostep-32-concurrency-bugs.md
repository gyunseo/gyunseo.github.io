---
pubDatetime: 2022-09-26T00:33:00Z
title: OSTEP 32 Concurrency Bugs
featured: false
tags:
  - OSTEP
  - Concurrency
  - Computer-Science
ogImage: ""
description: OS:TEP 32장 공부한 거 정리
---

## Table of contents

## 들어가며

대부분의 초기 병행성 관련 오류 연구는 `deadlock`에 초점이 맞추어져 있었다.
최근의 연구들은 다른 종류의 병행성 버그들 (비교착 상태 버그)을 다룬다.
이번 장에서 다룰 핵심 문제는 다음과 같다.

> **일반적인 병행성 관련 오류들을 어떻게 처리하는가?**
> 병행성 버그는 몇 가지의 전형적인 패턴을 갖는다.
> 튼튼하고 올바른 병행 코드를 작성하기 위한 가장 첫 단계는 어떤 경우들을 피해야 할지 파악하는 것.

## 오류의 종류

첫 번째 질문은 이것이다.

> **복잡한 병행 프로그램에서 발생하는 병행성 오류들은 어떤 것들이 있는가?**

대표적인 오픈 소스 프로그램 4개를 예로 들어 설명한다.

`MySQL` , `Apache`, `Mozilla`, `OpenOffice`
![](/public/image/ostep-32-concurrency-bugs-1695656687000.jpeg)
상기 표는 예로 든 병행 프로그램에서의 병행성 오류들을 표로 나타낸 것이다.
비교착 상태와 교착 상태의 오류로 나뉜 것을 알 수 있다.

## 비교착 상태 오류

상기 표를 보면 비교착 상태 오류가 병행성 오류의 과반수를 차지한다.

그것들은 어떤 종류일까?
어떻게 발생하는가?
어떻게 해결할 수 있는가?

대표적인 두 종류의 오류인 **원자성 위반(atomicity violation)** 과 **순서 위반(order violation)** 오류를 살펴본다.

#### 원자성 위반 오류 (atomicity violation)

![](/public/image/ostep-32-concurrency-bugs-1695656996684.jpeg)
상기 예제는 MySQL에서 발견한 간단한 예제이다.
`thd` 자료 구조의 `proc_info` 필드를 두 개의 딴 쓰레드들이 접근한다.
첫 번째 쓰레드는 그 필드가 NULL인지 검사하고, 두 번째 쓰레드는 그 필드를 NULL로 바꾼다.
만약 다음과 같은 상황을 가정해 보자.

1. 첫 번째 쓰레드가 검사를 완료한 후에, `fputs`를 호출하기 전에 interrupt가 발생한다.
2. 이로 인해서, 두 번째 쓰레드가 실행되어, 필드의 값을 NULL로 바꾼다.
3. `fputs`는 NULL 포인터 역참조를 하게 되어, 프로그램은 크래시된다.

원자성 위반 오류의 정의는 다음과 같다.

> **다수의 메모리 참조 연산들 간에 있어 예상했던 직렬성(serializability)이 보장되지 보장되지 않았다. (즉, 코드의 일부에 원자성이 요구됐으나, 실행 시에 그 원자성이 위반됐다.)**

어느 부분이 문제일까?

NULL값 검사와 `fputs` 호출 시 `proc_info`를 인자로 사용할 때, 원자적으로 실행되는 것 (_atomicity assumption_)을 가정했다.
근데, 이 가정이 깨진 것이다.

어떻게 해결할까?

락을 추가해, 어느 쓰레드든 `proc_info` 필드 접근 시, `proc_info_lock` 락 변수를 획득토록 한다.

![](/public/image/ostep-32-concurrency-bugs-1695658112849.jpeg)

### 순서 위반 오류 (order violation)

![](/public/image/ostep-32-concurrency-bugs-1695658149124.jpeg)
상기 코드에서 쓰레드 2의 코드는 `mThread`가 이미 NULL이 아닌 어떤 값으로 초기화 됐다고 가정했다.
하지만, 만약 쓰레드 1이 먼저 실행되지 않았다면, 쓰레드 2는 NULL 포인터를 사용하기 때문에 프로그램이 크래시될 것이다. (`mThread`의 초기값이 NULL이라고 가정했는데, NULL 값이 아닌 다른 값이라 한다면, 더 이상한 일이 발생한다. 임의의 메모리 주소를 접근하는 재앙이... NULL이라고 가정하여 크래시되는 게 낫다.)

순서 위반 오류의 정의는 다음과 같다.

> **두 개의 (그룹의) 메모리 참조 간의 순서가 바뀌었다. (즉, A가 항상 B보다 먼저 실행되어야 하지만 실행 중에 그 순서가 지켜지지 않았다)**

이런 오류를 수정하는 방법은 순서를 강제하는 것이다.
이런 종류의 동기화에는 컨디션 변수가 딱이다.

![](/public/image/ostep-32-concurrency-bugs-1695658465160.jpeg)
