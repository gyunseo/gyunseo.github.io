---
pubDatetime: 2023-09-26T03:52:00Z
title: OSTEP 33 Event-based Concurrency
featured: false
tags:
  - OSTEP
  - Concurrency
  - Computer-Science
  - OS
ogImage: ""
description: OS:TEP 33장 공부한 거 정리
---

## Table of contents

## 들어가며

이제까지 쓰레드를 병행 프로그램을 제작하는 유일한 도구인 것처럼 말했다.
하지만 그렇지 않다.
특히, GUI 기반 프로그램이나 인터넷 서버에서는 다른 스타일의 병행 프로그래밍이 사용된다.
이런 스타일을 event-based concurrency이라 한다.
`node.js`와 같은 서버 프레임워크에서 사용되지만, 그 시작점은 지금부터 다룰 C와 유닉스 시스템이다.
이벤트 기반의 병행성은 두 개의 문제를 갖고 있다.

1. 멀티 쓰레드 프로그램에서 이벤트 기반 병행성을 올바르게 사용하는 것이 매우 어렵다. (락을 누락시키거나, 교착 상태 또는 다른 골치 아픈 문제들이 발생할 수 있기 때문이다.)
2. 멀티 쓰레드 프로그램에서는 개발자가 쓰레드 스케줄링에 대한 제어권을 전혀 갖고 있지 않다는 것이다. 개발자는 OS가 생성된 쓰레드를 CPU들 간에 합리적으로 스케줄링하기만을 기대할 수밖에 없다.

핵심 질문은 다음과 같다.

> **어떻게 쓰레드 없이 병행 서버를 개발할까?**
> 쓰레드 없이 병행 서버를 구현할 때, 어떻게 병행성을 유지하면서 각종 문제들을 피할 수 있을까?

## 기본 개념: 이벤트 루프

우리가 다룰 방법은 언급한 이벤트 기반 병행성이다.
이 접근 방법은 단순하다.
특정 사건 (즉, "이벤트") 의 발생을 대기한다.
사건이 발생하면, 사건 (즉, "이벤트") 의 종류를 파악한 후, I/O를 요청하거나, 추후 처리를 위하면 다른 이벤트를 발생시키거나 하는 등의 작업을 한다.
고전적인 이벤트 기반의 서버가 어떻게 생겼는지 살펴보자.
이 응용 프로그램은 event loop라는 단순한 구조를 기반으로 짜여 있다.
코드는 하기와 같다.
![](/public/image/ostep-33-event-based-concurrency-1695669194022.jpeg)

매우 간단하다.
루프 안에서 사건 발생을 대기한다.
이벤트가 발생하면 하나씩 처리한다.
이때 각 이벤트를 처리하는 코드를 이벤트 핸들러(event handler)라 부른다.
중요한 건 이벤트의 처리가 시스템의 유일한 작업이기 때문에, 다음에 처리할 이벤트를 결정하는 것이 스케줄링과 동일한 효과를 갖는다.
스케줄링을 제어할 수 있는 기능이 이벤트 기반 방법의 큰 장점이다.
큰 질문이 생긴다.

> **발생한 이벤트가 무슨 이벤트인지 어떻게 판단할까?**

네트워크나 디스크 I/O의 경우 특히 쉽지 않다.
즉, 디스크 I/O가 완료됐다는 이벤트가 도착했을 때 어떤 디스크 요청이 완료됐느냐 하는 것이다.
좀 더 구체적으로 도착한 msg가 자신을 위한 것인지 어떻게 알까?

## 중요 API: `select()` (또는, `poll()`)

> **기본질문: 이벤트를 어떻게 받을까?**

대부분의 시스템은 `select()` 혹은 `poll()` 시스템 콜을 기본 API로 제공한다.
interface의 기능은 간단하다.
도착한 I/O들 중 주목할 만한 것이 있는지를 검사한다.
예를 들어, 웹 서버 같은 네트워크 응용 프로그램이 자신이 처리할 패킷의 도착 여부를 검사하는 것이다.
이 시스템 콜들이 정확히 해당 역할을 한다.
`select()`를 예로 살펴보자.
Mac OS X가 제공하는 메뉴얼은 이 API를 다음과 같이 설명한다.
![](/public/image/ostep-33-event-based-concurrency-1695669543207.jpeg)
메뉴얼의 내용은 다음과 같다.

> `select()`는 `readfds`, `writefds`, 그리고 `errorfds`를 통해 전달된 I/O 디스크립터(descriptor) 집합들을 검사해서, 각 디스크립터 들에 해당하는 입출력 디바이스가 읽을 준비가 되었는지, 쓸 준비가 되었는지, 처리해야 할 예외 조건이 발생했는지 등을 파악한다.
> 각 집합의 첫 번째 `nfds` 개의 디스크립터들, 즉 `0` 부터 `nfds-1`까지의 디스크립터를 검사한다.
> `select`는 집합을 가리키는 각 포인터들을 준비된 디스크립터들의 집합으로 교체한다.
> `select()`는 전체집합에서 준비된 디스크립터들의 총 개수를 반환한다.

(~~무슨 말이지?~~)

`select()`에 대한 두 가지 알아두어야 할 것이 있다.
첫 번째, `select()`를 이용하면 디스크립터에 대한 읽기 가능여부, 쓰기 가능여부를 검사할 수 있다.
전자는 처리해야 할 패킷의 도착 여부를 파악할 수 있도록 한다.
후자는 서비스가 응답전송이 가능한 시점 (예를 들어, 아웃바운드 큐가 가득 차지 않았다.) 을 파악토록 해준다.
두 번째는 `timeout` 인자의 존재이다.
일반적으로 NULL로 설정한다.
그러면 `select()` 디스크립터가 준비될 때까지 무한정 대기한다.
하지만, 오류에 대비토록 설계된 서버들의 경우 `timeout` 값을 설정해 두기도 한다.
널리 사용되는 방법으로는 `timeout` 값을 0으로 설정해, `select()`가 즉시 리턴토록 하는 것이다.
`poll()` 시스템 콜도 유사하다.
이런 기본 함수로 non-blocking event loop를 만들어, 패킷 도착을 확인하고, 소켓에서 메시지를 읽고 필요에 응답할 수 있도록 해준다.

### 여담: 차단 (blocking) 과 비차단 (non-blocking) 인터페이스

차단 (또는 synchronous) 인터페이스는 호출자에게 리턴하기 전에 자신의 작업을 모두 처리하는 반면 비차단 (또는 asynchronous) 인터페이스는 작업을 시작하기는 하지만, 즉시 반환하기 때문에 처리되어야 하는 일이 background에서 완료가 된다.
차단 호출은 주로 I/O 때문에 발생한다.
예를 들어, 작업 완료를 위해서 disk에서 읽어야 하는 자료가 있다면, disk에 요청한 I/O 요청을 대기해야 한다.
non-blocking interface는 모든 프로그래밍 (예, 멀티 쓰레드 프로그래밍) 스타일에서 사용될 수 있다.
하지만, event-based programming에서는 필수적이다.
왜냐면, 차단 방식의 시스템 콜 (blocking call)이 전체 시스템을 멈출 수 있기 때문이다.
